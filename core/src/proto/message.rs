// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Message {
    /// 消息id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// 时间戳(单位:毫秒)
    #[prost(uint64, tag = "2")]
    pub ts: u64,
    /// 消息类型
    #[prost(enumeration = "Type", tag = "3")]
    pub r#type: i32,
    #[prost(oneof = "message::Content", tags = "4, 5, 6, 8, 9")]
    pub content: ::core::option::Option<message::Content>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "4")]
        ConnectRequest(super::ConnectRequest),
        #[prost(message, tag = "5")]
        ConnectResponse(super::ConnectResponse),
        #[prost(message, tag = "6")]
        Chat(super::Chat),
        #[prost(message, tag = "8")]
        Ping(super::Ping),
        #[prost(message, tag = "9")]
        Pong(super::Pong),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectResponse {
    #[prost(uint32, tag = "1")]
    pub code: u32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub uid: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Chat {
    #[prost(uint64, tag = "1")]
    pub speaker: u64,
    /// 所发生的聊天室id
    #[prost(uint64, tag = "2")]
    pub room: u64,
    #[prost(enumeration = "ChatType", tag = "3")]
    pub r#type: i32,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub ts: u64,
    #[prost(string, tag = "6")]
    pub nickname: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ping {
    #[prost(uint64, tag = "1")]
    pub ts: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Pong {
    #[prost(uint64, tag = "1")]
    pub ts: u64,
    #[prost(uint64, tag = "2")]
    pub latency: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Room {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// repeated Chat chats = 3;
    #[prost(bool, tag = "2")]
    pub unread: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pull {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<pull::Request>,
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<pull::Response>,
}
/// Nested message and enum types in `Pull`.
pub mod pull {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        /// 是否全部拉取，包括消息内容
        /// false = 只拉取每个聊天室是否有未读的消息
        /// true = 拉取指定聊天室中未读取的所有消息
        #[prost(bool, tag = "1")]
        pub full: bool,
        /// 指定拉取的聊天室id
        #[prost(uint64, tag = "2")]
        pub room: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, repeated, tag = "1")]
        pub rooms: ::prost::alloc::vec::Vec<super::Room>,
    }
}
/// Chat chat = 1;
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Push {}
/// 不需要内容的消息
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct None {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Error {
    #[prost(int32, tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
    /// 连接初始化，携带令牌
    ConnectRequest = 0,
    ConnectResponse = 1,
    Chat = 2,
    /// 心跳消息
    Ping = 6,
    Pong = 7,
}
impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ConnectRequest => "CONNECT_REQUEST",
            Self::ConnectResponse => "CONNECT_RESPONSE",
            Self::Chat => "CHAT",
            Self::Ping => "PING",
            Self::Pong => "PONG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECT_REQUEST" => Some(Self::ConnectRequest),
            "CONNECT_RESPONSE" => Some(Self::ConnectResponse),
            "CHAT" => Some(Self::Chat),
            "PING" => Some(Self::Ping),
            "PONG" => Some(Self::Pong),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatType {
    /// * 文本
    Text = 0,
    /// * 表情
    Emoji = 1,
    /// * 图片
    Image = 2,
    /// * 代码
    Code = 3,
    /// * 富文本
    Rtf = 4,
}
impl ChatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Text => "TEXT",
            Self::Emoji => "EMOJI",
            Self::Image => "IMAGE",
            Self::Code => "CODE",
            Self::Rtf => "RTF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEXT" => Some(Self::Text),
            "EMOJI" => Some(Self::Emoji),
            "IMAGE" => Some(Self::Image),
            "CODE" => Some(Self::Code),
            "RTF" => Some(Self::Rtf),
            _ => None,
        }
    }
}
