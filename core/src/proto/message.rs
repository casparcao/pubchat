// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Message {
    /// 消息id
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// 时间戳(单位:毫秒)
    #[prost(uint64, tag = "2")]
    pub ts: u64,
    /// 消息类型
    #[prost(enumeration = "Type", tag = "3")]
    pub mtype: i32,
    #[prost(oneof = "message::Content", tags = "4, 5, 6, 7, 8, 9")]
    pub content: ::core::option::Option<message::Content>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "4")]
        Cort(super::Cort),
        #[prost(message, tag = "5")]
        Cors(super::Cors),
        #[prost(message, tag = "6")]
        Chrt(super::Chrt),
        #[prost(message, tag = "7")]
        Chrs(super::Chrs),
        #[prost(message, tag = "8")]
        Ping(super::Ping),
        #[prost(message, tag = "9")]
        Pong(super::Pong),
    }
}
/// ConnectRequest
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Cort {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// ConnectResponse
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Cors {
    #[prost(uint32, tag = "1")]
    pub code: u32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub uid: u64,
    #[prost(string, tag = "4")]
    pub uname: ::prost::alloc::string::String,
}
/// ChatRequest
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Chrt {
    #[prost(uint64, tag = "1")]
    pub sender: u64,
    /// 发送者昵称
    #[prost(string, tag = "2")]
    pub uname: ::prost::alloc::string::String,
    /// 所发生的聊天室会话id
    #[prost(uint64, tag = "3")]
    pub session: u64,
    #[prost(uint64, repeated, tag = "4")]
    pub receivers: ::prost::alloc::vec::Vec<u64>,
    #[prost(enumeration = "ChatType", tag = "5")]
    pub ctype: i32,
    #[prost(uint64, tag = "6")]
    pub ts: u64,
    #[prost(oneof = "chrt::Message", tags = "7, 8")]
    pub message: ::core::option::Option<chrt::Message>,
}
/// Nested message and enum types in `Chrt`.
pub mod chrt {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "7")]
        Text(super::Text),
        #[prost(message, tag = "8")]
        Blob(super::Blob),
    }
}
/// ChatResponse
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Chrs {
    #[prost(uint64, tag = "1")]
    pub sender: u64,
    /// 发送者昵称
    #[prost(string, tag = "2")]
    pub uname: ::prost::alloc::string::String,
    /// 所发生的聊天室会话id
    #[prost(uint64, tag = "3")]
    pub session: u64,
    #[prost(uint64, tag = "4")]
    pub receiver: u64,
    #[prost(enumeration = "ChatType", tag = "5")]
    pub ctype: i32,
    #[prost(uint64, tag = "6")]
    pub ts: u64,
    #[prost(oneof = "chrs::Message", tags = "7, 8")]
    pub message: ::core::option::Option<chrs::Message>,
}
/// Nested message and enum types in `Chrs`.
pub mod chrs {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "7")]
        Text(super::Text),
        #[prost(message, tag = "8")]
        Blob(super::Blob),
    }
}
/// 普通文本消息
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Text {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
/// 文件消息
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Blob {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub size: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub exp: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ping {
    #[prost(uint64, tag = "1")]
    pub ts: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Pong {
    #[prost(uint64, tag = "1")]
    pub ts: u64,
    #[prost(uint64, tag = "2")]
    pub latency: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Session {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// repeated Chat chats = 3;
    #[prost(bool, tag = "2")]
    pub unread: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pull {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<pull::Request>,
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<pull::Response>,
}
/// Nested message and enum types in `Pull`.
pub mod pull {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        /// 是否全部拉取，包括消息内容
        /// false = 只拉取每个聊天室是否有未读的消息
        /// true = 拉取指定聊天室中未读取的所有消息
        #[prost(bool, tag = "1")]
        pub full: bool,
        /// 指定拉取的聊天室id
        #[prost(uint64, tag = "2")]
        pub session: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, repeated, tag = "1")]
        pub sessions: ::prost::alloc::vec::Vec<super::Session>,
    }
}
/// Chat chat = 1;
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Push {}
/// 不需要内容的消息
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct None {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Error {
    #[prost(int32, tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
    /// 连接初始化，携带令牌
    Cort = 0,
    Cors = 1,
    Chrt = 2,
    Chrs = 3,
    /// 心跳消息
    Ping = 6,
    Pong = 7,
}
impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Cort => "CORT",
            Self::Cors => "CORS",
            Self::Chrt => "CHRT",
            Self::Chrs => "CHRS",
            Self::Ping => "PING",
            Self::Pong => "PONG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CORT" => Some(Self::Cort),
            "CORS" => Some(Self::Cors),
            "CHRT" => Some(Self::Chrt),
            "CHRS" => Some(Self::Chrs),
            "PING" => Some(Self::Ping),
            "PONG" => Some(Self::Pong),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatType {
    /// * 文本
    Text = 0,
    /// * 表情
    Emoji = 1,
    /// * 图片
    Image = 2,
    /// * 代码
    Code = 3,
    /// * 富文本
    Rtf = 4,
    /// * 文件
    File = 5,
}
impl ChatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Text => "TEXT",
            Self::Emoji => "EMOJI",
            Self::Image => "IMAGE",
            Self::Code => "CODE",
            Self::Rtf => "RTF",
            Self::File => "FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEXT" => Some(Self::Text),
            "EMOJI" => Some(Self::Emoji),
            "IMAGE" => Some(Self::Image),
            "CODE" => Some(Self::Code),
            "RTF" => Some(Self::Rtf),
            "FILE" => Some(Self::File),
            _ => None,
        }
    }
}
